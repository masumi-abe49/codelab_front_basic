◆CSS詳細度とは

　詳細度（Specificity）は、どのCSSプロパティが要素に最も関係があるか、すなわち適用されるかをブラウザーが決定する手段。
　→「スタイルが重複したとき，どのスタイルを優先するか」の優先度を定量評価したもの。

詳細度は様々な組み合わせのCSSセレクターで構成される一致規則に基づいている。

詳細度はCSS宣言が適用される際の重みであり、一致するセレクターそれぞれの種類の数によって特定される。
複数の宣言が同じ詳細度であれば、CSSの中で最後に宣言されたものが要素に適用される。
詳細度は同じ要素に対して複数の宣言が行われている場合のみ適用される。
CSSの規則として、直接対象となった要素は要素が祖先から継承した規則よりも常に優先される。

***********

優先度　高　→ a → b → c 低

・全称セレクタ: a=0, b=0, c=0
　*

・要素，擬似要素: a=0, b=0, c=1
　li, ::before, ::first-line, etc.

・クラス，擬似クラス，属性: a=0, b=1, c=0
　.classname, :first-child, [type=password], etc.

・id: a=1, b=0, c=0
　#idname


各桁ごとに雑に足せば詳細度がわかりやすくなる。

***********


バージョン番号のように考えた場合

・#i1 #i2: 2.0.0
・#i1 .c{1..11}: 1.11.0

＝＝＝＝＝

・詳細度はバージョン番号のようなものとして考える
・#idnameはなるべく使わず.classnameや属性を優先して使用してみる
・インラインスタイルはNG（style=""）
・基本的に!importantは使わない（詳細度が高過ぎるため後で厄介に。。。）

＝＝＝＝＝

★参考URL　Qiita 詳細度：https://qiita.com/izumin5210/items/8ae78cb4f4bd325bccb4#a1


◆スタイルの継承とは

・親要素から子要素へのスタイルの継承

　プロパティには、親要素に指定した値が子要素に継承されるものと継承されないものがある。
継承されるものには文字色や文字サイズに関するプロパティなどがある。
一方、ボーダー・マージン・パディング・背景画像など、値が継承されないプロパティもある。

・「inherit」を指定すると強制的に値を継承する。
　ほぼすべてのプロパティには、親要素の値を強制的に継承する「inherit」という値を指定することができる。
この値を指定することで、通常は値を継承しないボーダー・マージン・パディング・背景画像などのプロパティも値を継承するようになる。

・相対的な値の継承
　親要素から子要素へ文字サイズなどの値が継承される場合、 pt・pxなどの単位の場合にはそのままの値が継承されるが、他の要素サイズとの関係で算出される%・em・exなどの「相対的な単位」の場合には、親要素と子要素の値を掛け合わせた結果の値が継承されます。

例えば、親要素と子要素のそれぞれに文字サイズ90%を指定した場合、 子要素である<p>要素の文字サイズは90%ではなく、90%×90%＝81%となる。

★参考URL ：http://www.htmq.com/csskihon/008.shtml


◆marginの相殺とは

　マージンの相殺は、垂直マージンを指定した2つのブロックレベル要素が並んだ時に起こる。
マージンの相殺が起こると、2つのマージンのうち大きい方（等しい場合はいずれか）が1つのマージンとしてみなされる。
2つのdiv要素がありAのdiv要素は10pxのmargin-bottomを、Bのdiv要素には30pxのmargin-topを指定したとする。
この2つのブロックレベルの要素をマークアップで順番（垂直）に並べると2つの要素の間にあるマージン（10pxと30px）は「マージンの相殺」が起き、大きい方のマージンである30pxのマージンが残る。

・marginの相殺はいつ起こるのか

原則として、インフロー、ブロックレベル、ボックス間の隣接する垂直マージンは常に相殺される模様。

ケース1: 親と最初の子の上マージン
margin-topが親要素に指定し、インフローの最初の子要素にも指定した場合、それらのマージンは相殺される。
（インフローで相殺される隣接する垂直マージン）

ケース2: 親と最後の子の下マージン
ケース1と同じように、margin-bottomが親要素に、インフローの最後の子要素にも指定した場合、マージンは相殺される。
（インフローで相殺される隣接する垂直マージン）
※ただし、上マージンとは異なり、下マージンは親の高さがautoの場合にのみ相殺される。

ケース3: 兄弟要素の下と上のマージン
このケースは、上記で提示した例のもの。
margin-bottomを1つ目の要素に、margin-topを2つ目の要素に指定した場合、それらの間にあるマージンは相殺され、
兄要素の「margin-bottom: 10px;」、弟要素の「margin-top: 30px;」は相殺され、マージンは30pxで表示される。
（ブロックレベルで相殺される隣接する垂直マージン）

ケース4: 空の要素
最後は要素の高さが0、いわゆる空の要素にmarign-bottomとmargin-topを指定した場合、それらのマージンは相殺される。
空要素の「margin-bottom: 30px;」と「margin-top: 30px;」は相殺され、マージンは30pxで表示される。
（ボックス間で相殺される隣接する垂直マージン）

例外
マージンの相殺が起きない例外も少数ある模様。

　・Flexbox、Grid、その他のブロックレベルでない要素

　　マージンの相殺はブロックレベルの要素にのみ適用される。つまり、displayプロパティの値がblock, list-item, tableのいずれかの時。そのため、flexアイテムやgridアイテムや絶対値アイテム、そしてブロックレベルではない要素には適用されない。
　・ルート要素
　　ルート要素のボックスのマージンは絶対、相殺されない。

　・ボーダーやパディングを使ったラインのボックス
　　2つの要素間にあるラインのボックス、パディングやボーダーがある場合、相殺されない。ケース1では親と最初の子の上マージンは相殺されましたが、これにボーダーを加えるだけで、相殺されなくなる。
理由は、「親のマージンと子のマージンは直接接触していないから」、とのこと。

＜marginの相殺を回避するテクニック＞
マージンの相殺がいつ発生するのかを正しく理解していないと、思い通りのレイアウトができないで困ることがある。
それを回避するための第一歩は、「その相殺がどのケースなのか」を正確に理解すること。

空要素や親子要素で起きるマージンの相殺は、実際には避けることができない模様。
これに対応する唯一の方法は、「要素の間にボーダーなど何かを挿入すること」。
ほかの対応方法としては、要素のプロパティをブロックレベル以外（flex, gridなど）に変更すること。

隣接する兄弟要素で起きるマージンの相殺は、CSSのスタイルを変更することで回避することができる。
「マージンの指定は単一方向にする」とわかりやすくなる（？）らしい。

★参考URL ：https://coliss.com/articles/build-websites/operation/css/about-collapsing-margins.html


◆カラム落ちとは

カラム落ちは、合計幅が全体の固定幅を超えて横並びに表示ができなくなった時に起こる。
回り込みの指定の間違いや、レイアウトサイズのズレが生じると、カラム落ちやレイアウト崩れがおきるということ。

パターンA　[横幅の足し算の勘違い]
　→widthの値を確認する

パターンB　[marginの読み込みがブラウザによって異なる]
　→複数のブラウザでの表示を確認する必要がありそう。

パターンC　[floatやtext-alignのright・left指定をミスするとカラムが落ちる]
　→回り込み設定を無効にしている 記述 部分　をボックスの中に入れる事で修正。
 　(回り込み設定とは、float : left; または float : right ; のcss設定の事。)

★参考URL ：http://cid2017web.blogspot.com/2017/10/blog-post.html


◆ベースラインとは

　ベースラインとは文書内に配置されたプレーンテキストの下に仮想的に存在する線。
テキストを打ちこむと、当然のように文字はその線上にキレイに並ぶ。
しかし、英語の場合は小文字のgやy、j等、このベースラインから下にはみ出すものがある。
通常、文字を打ちこんだ場合このベースラインはデフォルトスタイルシートで vertical-align:baseline に設定されている。
つまり何も考えなくても常にテキストの下にはgやyの為に常に隙間があいているという事になります。

しかし、このプロパティーは別にその行のベースラインそのものを動かすわけではなく、あくまでテキストの行の中での高さをコントロールするものなので、同じ大きさの文字を打つ分にはそのベースラインが狂う事はない。
普通にテキストを打つだけなら問題にはならない。

　画像を配置する時に気をつけること。
img要素はエンベッディッド・コンテンツであるとともにフレージング・コンテンツ(HTML5以前で言うインライン要素の様なもの)であるらしいため、基本的にはテキストと同じ扱いにされる。
画像と文字を並べた場合や画像を縦に並べた場合、下に隙間が出来てしまう。
img{vertical-align:bottom;} や、
img{display:block;} としてみると良いらしい。

ベースラインはフレージング・コンテンツにしか存在しないからです(vertical-alignもフレージング・コンテンツかテーブル・モデルのセルにしか指定できない)。

★参考URL：http://webcre8.jp/investigate/html-implied-specifications.html


◆ベンダープレフィックスとは

・先頭に付ける-moz-や-webkit-など
　CSS3で採用される予定の機能が各ブラウザで先行実装されていますが、それらの機能を動作させるには、 現状ではプロパティや値の先頭に-moz-や-webkit-などの「ベンダープレフィックス」を付ける必要がある。

例えば、border-imageプロパティで画像ボーダーを機能させるには、 FirefoxやGoogle Chromeなどのそれぞれのブラウザ向けのベンダープレフィックスを付ける必要がある。

【例】
　-moz-border-image: url("bg_dot.png") 15 round;　　　　 // Firefox向け
　-webkit-border-image: url("bg_dot.png") 15 round;　　　// Google Chrome、Safari向け

・拡張機能であることを明示するための識別子
　ベンダープレフィックス（接頭辞）とは、ブラウザベンダーが独自の拡張機能を実装したり、草案段階の仕様を先行実装する場合に、それが拡張機能であることを明示するために付ける識別子のこと。
将来的に仕様が変更されるリスクに備えて、独自拡張や先行実装のプロパティ名や値の先頭に付けることが推奨されている。ベンダープレフィックスでは、前後に「-」を付けたベンダー識別子（vendor identifier）でブラウザの種類を特定する。

【主要ブラウザのベンダープレフィックス】
-moz-　　…… Firefox ←調べ物するとたまに見かけていた
-webkit-　…… Google Chrome、Safari ←調べ物するとたまに見かけていた
-o-　　　　…… Opera
-ms-　　　…… Internet Explorer

・ベンダープレフィックス無しの指定も併記する
　CSS3が勧告されるまでには、まだ時間が掛かることが予想されるが、 今後審議を重ねる中で仕様変更・一部機能の廃止・新機能の追加が行われる可能性がある。
ベンダープレフィックスは草案段階の機能を実装する際に付けることが推奨されているので、 これらの機能を利用する際には当面ベンダープレフィックスを付ける必要がある模様。

※※ただし、ベンダープレフィックスは、 草案（Working Draft）が「勧告候補（Candidate Recommendation）」になったときには【外すことが推奨】されている。
すでにGoogle ChromeやFirefoxなどのブラウザでは、CSS3の機能の一部がベンダープレフィックス無しで動作するようになっており、 また、新しいブラウザでは【ベンダープレフィックスが付いていると、逆に動作しなくなっている】機能もあるとのこと。

ベンダープレフィックスを付けないと現状では動作しないプロパティや値を指定する際にも、 今後の仕様策定の進展やブラウザのバージョンアップに備えて、 ベンダープレフィックス無しの指定を併記しておくほうが良い。

【border-image（画像にボーダーを付けるプロパティ）の記入例】

border-image: url("bg_dot.png") 15 round;　　　　 　　　　//ベンダープレフィックス無し（標準）も併記する
-moz-border-image: url("bg_dot.png") 15 round;　　　　 // Firefox向け
-webkit-border-image: url("bg_dot.png") 15 round;　　　// Google Chrome、Safari向け

★参考URL：http://www.htmq.com/csskihon/603.shtml


◆レスポンシブWEBデザインとは

　レスポンシブWebデザインとは、「どんな大きさの画面でも見やすく、使いやすいWebサイトにするために必要なもの」。
1つのHTML（Webサイトに載せる情報）で配信し、「CSS（情報の大きさや位置など表示の指定）はデバイスごと（PC、スマホ、タブレットなど）に用意」して表示を変えさせる。
内容は全て同じですが【見せ方が違う】ということ。

◎メリット◎
・管理が楽
　HTMLが１つなのでWebサイトに載せる情報を修正や更新する時に作業が1回で済む。
デバイスごとにHTMLがあると修正や更新の作業をHTMLの数だけしなくてはならない。

・シェアされやすい
　URLが1つなのでWebサイトを見るユーザーにシェアされやすくなる。
スマホ用のモバイルサイトとパソコン用のPCサイトがあった場合、見せたいユーザーのデバイスに合わせて異なるURLを送らなければなりません。

・検索エンジンの上位に表示されやすい
　スマホに対応したWebサイトが検索結果の上位に表示されやすくなる「モバイルフレンドリー」や、スマホ用のページが順位の決め手になる「モバイルファーストインデックス」に対応できる。

*****
「モバイルフレンドリー」
モバイルフレンドリーとは、「サイトがモバイル端末を使用するユーザーにとって、使いやすい・見やすいなどユーザー体験を損ねない状態であること」。

「モバイルファーストインデックス」
モバイルファーストインデックスとは、これまで、Webサイトの順位はPCサイトの内容や構成をプライマリ(主軸)として評価され、モバイルサイトはセカンダリ(副軸)として評価されていたが、
「これまでの評価軸が転換し、モバイルサイトの評価がメインで評価されるようになる」アルゴリズムのこと。

◆どちらもSEOに関する用語のようです。
★参考URL：https://digitalidentity.co.jp/blog/seo/catch-mobile-seo-words.html
*****

△デメリット△
・スマホでの表示に時間がかかる
　HTMLが1つなのでパソコンと同じデータをスマホにも読み込ませることとなる。
そのため、スマホで表示しないデータも読み込まれ、表示完了するまで時間がかかってしまう。
（どれくらい時間がかかるのかはGoogleの「PageSpeed Insights」で測定できる模様。）

・デザインに制限がある
　HTMLが1つなのでスマホとパソコンでコンテンツの順番を変えるなど、大幅に見せ方を変えることはできない。

・工数がかかる
　デバイスごとにデザインを制作し、それに合わせたコーディングをするので複雑になります。
そのため制作工数がかかってしまう。

★参考URL：https://digitalidentity.co.jp/blog/creative/responsive-web-design.html
（レスポンシブWebデザインの作り方についても記載あり。メディアクエリなど。）


◆floatの解除の方法3つ

「floatの解除・回避方法」
　floatを使用した場合、「指定した要素から子要素が認識できなくなり、そのため親要素は高さを保持できなくなる」。

１．clear: both; を利用した解除←レイアウトの課題で一度やっていそうな方法
　回り込みを解除するプロパティで。指定方法は【floatを指定した要素の次の要素に指定】する。floatが連続している場合は【最後の要素に指定】する。

※デメリット※
　子要素がすべてfloat指定している場合には使えない。float指定した要素にclear: both; を指定すると回り込みが行われない。ナビゲーションなど、すべての子要素がfloatする場合には使えない。
またclear: both; を使用した要素はmargin-topとmargin-bottomが使用できなくなる。

◇テクニック◇
　連続したfloat要素の途中で折り返したい場合は、【折り返す要素にfloatとclearを併用する】と、折り返すことができる。←折り返したい項目にclass名を指定してclear: bothを記入してみる。

２．親要素に高さ（heightプロパティ）を指定して回避
　float指定した要素の高さが変更されない場合は【親要素にheightを指定して回避】することができる。
ナビゲーションなど高さの増減がない場所に使用します。

※デメリット※
　親要素内（例えばulタグなど）のコンテンツが増えると指定した高さより、はみ出した部分が次のエリアに重なってしまう。

３．親要素にoverflow:hidden;を指定して回避
　子要素がすべてfloat指定している場合、【親要素にoverflow:hidden;を指定すると親要素が高さを保持】することができる。
○親要素にheightを指定する場合と違い、【コンテンツが増減しても高さを可変させることができる】。

※デメリット※
　overflow:hidden;を指定した要素から、はみ出した部分が非表示になってしまう。positionプロパティを使った「絶対配置」の場合に注意が必要。

◇overflowプロパティ（オーバーフロウ）とは
　指定した要素の幅、高さより子要素の幅、高さが大きい場合に、はみ出した部分をどのように処理するかのプロパティ。主な値は下記のようなもの。

・visible・・・はみ出した部分を表示（初期値）
・hidden・・・はみ出した部分を非表示
・scroll・・・スクロールバーを常に表示
・auto・・・子要素がはみ出す場合はスクロールバーを表示

４．親要素にclearfixを指定して解除
　clearfix（クリアフィックス）とはCSSのテクニックの一つ。
clearfixは親要素で指定する。clearfixには様々な手法があるが、どれもfloat問題を回避するためのテクニック。
clearfixは【親要素内の最後の子要素をCSSで擬似的に作り出し、それにclear: both;を指定してfloatを解除】するもの。「擬似要素にheight:0;を指定している」ため、見た目には存在しないようになっている。

↓は様々なclearfixの中から「micro clearfx」という手法となる。
IE6 / 7に対応する必要がなければ最後の行は削除してもOKらしい。

**********

子要素（liタグなど）がfloat指定している親要素に指定する
↓
【CSS 例】

/* micro clearfx を使う場合 */
.〇〇:before, .〇〇:after {
    content: "" ;
    display: table;
}

.〇〇:after { clear:both }

.〇〇 { zoom:1 } /* For IE 6/7 */

**********

※デメリット※
　大きなデメリットはなさそう。様々なclearfixが公開されているので、どれを使えばよいかの判断に悩む可能性はあり。ただclearfixはすべて目的は同じなので、どれを使っても特に問題はないとのこと。

＝＝＝＝＝
・floatの解除はoverflow:hidden; または clearfix を利用する
・overflow:hidden; と clearfix は親要素に指定するテクニック
・場合によってclear: both; または 親要素に height を指定して回避する
＝＝＝＝＝

★参考URL：https://web-manabu.com/html-css39/


◆見出しタグの使い分け

　見出しタグは内部SEOの面で非常に重要なものであり、使い方を間違えるとSEO的に悪影響を被ってしまう。

見出しタグとは、ユーザーと検索エンジンの双方にページ内のコンテンツ構成を正しく伝えるために使用する技術のこと。
見出しタグは1~ 6まであり数字が若いほど重要度が上がる。
　→<h1>〜<h6>

見出しタグの適切な使用には、

・ページのユーザビリティを上げる
・ページのSEO効果を上げる

という２つのメリットがある。

※見出しタグを使う時の注意点※

・ページ構成と関係ない意図で使わないこと
　→見出しタグはテキストの見た目を調整するためのものではなく、あくまでもページ上の階層構造をユーザーや検索エンジンにとって分かりやすく示すために使うもの

・見出し1<h1>は１ページに１つにすること
　→h1タグは、そのページでもっとも重要なテキストに対して使用するタグ。例えば、サイトのトップページであればサイトタイトルが、記事ページであれば記事タイトルが、そのページでもっとも重要なテキストになる。そのためh1タグは、タイトルに設定するのが自然。
 また、ほとんどのWordPressテーマでは、自動的にタイトルに<h1>が付くようになっている模様。
（※h1とtitleタグには同じテキストを設定しておくことが望ましいという意見もあり。タイトルタグは、SEOの観点から見ると、そのページの要素の中でも最重要と言えるもの。そしてh1タグも同じように、そのページ内で最も重要なテキストを示すためのタグ。従って、両者には同じテキストを設定しておくことが望ましいという意見も。）

・見出しタグの順番を守ること
　→見出しタグは<h1>から始まり<h6>まであるが、<h1>の次に来るのは<h2>、<h2>の後に来るのは<h3>というように順番を守らなければいけない。
見出しタグはコンテンツの階層構造を正しく示すために使うもの。
見出しタグの順番が守られていないということは、【その階層構造を正しく示せていないということ】になる。それでは、結果的にSEOにマイナスの影響を与えてしまう。

　→→→これらの点を守らなければ、SEO面で悪影響が出てしまう。

---------

◇効果的な見出しを作るための基礎的な２つのテクニック◇

１．見出しを見ただけで内容が分かるようにすること
　WEBユーザーの中には、最初にページにアクセスした時に一度ページの一番下までスクロールして全体の内容を理解しようとする人も少なくない。
そうやってスクロールした時に「おっ、これは気になるから読んでみよう」というようなひっかかりがなければ、そのユーザーはそのままページから離脱してしまう。
その状況を防ぐために有効なのが、【見出しを見ただけで全体の内容が分かるようにすること】。

◎見出しは、本の目次のように考えて設定してみる◎

２．見出しは文の形にしないこと
　上述したように、見出しは一瞬読み流した時に「おっ、これは気になる」と思って立ち止まり、読み進めてもらえるように促す役割がある。そのような場合、どれだけ魅力的な見出しだとしても、【文字数が多いと、引っかかる前に読み飛ばしてしまう】。

つまり、【見出しは短い方が目に留まりやすい】ということだ。

見出しを短くするには、見出しは文の形ではなく、最後は名詞でおわる文言を考えるのが有効だ。

A：なぜWordPressがSEOに強いのか？
B：WordPressがSEOに強い理由

後者の方が、具体的で興味を持ってもらいやすく、なおかつ前者より文字数も少ない。 

このように、【見出しは魅力的かつ、流し読みする人が一瞬で内容を把握できる程度の短さ】になるように、常にこころがける。

★参考URL：https://bazubu.com/how-to-use-h-tags-26344.html


◆box-sizing: border-box;

box-sizingとは、要素の高さや幅をどこの領域までにするかを指定するもの。
border-boxは、幅と高さに、パディングとボーダー領域を含む。※マージン領域は含まない。
（マージンを入れたい場合は、css3ではマージン分を引いた分を横幅に指定することで解決出来る模様。）

★参考URL ：https://qiita.com/ritukiii/items/8da5d23afd84b1385285


◆marginとpaddingの違い

「marginは枠線（border）の外側」に、「パディングは枠線（border）の内側」に余白ができる。

　実際のコーディングでborderを指定して、要素に枠線を付けるとはっきりと違いが分かる。
もう一つ重要なのは、要素にbackgroundタグで背景色や背景画像を置く場合、枠線の時と同じように「marginは背景の外側」に、「paddingは背景の内側」に余白ができます。

・marginとmarginは相殺する。
　margin-bottom:20px;とmargin-top:30px;の要素が上下にならんでいた場合、2つの要素の間隔は「20+30=50ピクセル」にはならず【重なったマージンは相殺され、上下の間隔は30ピクセル】となる。
　※padding-bottom:20px;とpadding-top:30px;だと50ピクセル余白ができる。

・marginは負の値が使える。
　marginは値に【マイナスの数字】を使うことが可能。
margin-left:-10px;を指定すると本来表示される大きさより左に10pxはみ出して表示される。
　※paddingには負の値は使えない。

・marginはautoが使える。
　【ブロック要素をセンタリングしたい場合】に使う。
幅を指定したdivにmargin-left:auto;とmargin-right:auto;を指定すると、外側の要素から見て左右真ん中にdivが配置されます。
↑margin: 0 auto; と同じことだと思う。

※paddingにはautoは使えない。

★参考URL：https://klutche.org/archives/443/


◆articleタグとsectionタグの違い

セクショニング要素（sectionタグとは別）とは、「範囲（章・節・項など）を明確にするための要素」を指す。
（文書の構造をより分かりやすくするための要素の総称）

◇セクションを表す要素◇

・section…その範囲が一般的な章・節・項などであることを示す要素。
　→「文書に階層をつける」時には「section」が必要。
　　見出しタグであるh1タグやh2タグをそれぞれsectionタグで囲む。
　　これにより、各セクションが「章・節・項」であることを明示。
　　（例えばh2タグをsectionタグで囲んで「節」とし、その次に来るh3タグをsectionタグで囲んで「項」としたりする）

・article…その範囲がセクションの中で、独立しており、それだけで完結していることを示す要素。
　→「article」とは「記事」や「論説」といった意味の英単語で、最も分かりやすいのは、「ブログのエントリやコメント」が挙げられる。
　　例えば、ブログタイトルと、本文の部分を<article>で囲み、ブログに対するコメント部分も囲む。そして、全体としてもう一度<article>で囲んだりする。独立して完結している要素を<article>で囲むことができる。

その他にも以下のようなセクションを表す要素がある。

・aside…その範囲がページの中で、メインコンテンツとは関連性が低い補足や広告などを示す要素。
　→本文とは関連性の低い補足情報などを<aside></aside>で囲んで使用する。
　　（あくまでも関連性が「低い」のであって「無関係」な内容に「aside」を使用することは不適切となる）

・nav…その範囲がナビゲーションであることを示す要素。
　→主に、各ページへのリンクに対して使用されることが多い要素だが、重要なのは「主要なナビゲーション」に対してのみ使用するという事。

※div要素との違い
　divは、意味を持たない汎用的な要素。他に適当なタグが無い場合に使用し、【要素をグループ化する役割】として使用する。


◆サイズの単位 px、%、em、remの違い

　CSSにおける単位というのは、絶対単位と相対単位に分類される。
例えば、mm（ミリメートル）。CSSでmmを使うことはほとんどないが、指定することができる。
1mmはどんな環境でも1mmとなる。
このような単位を「絶対単位」と呼ぶ。

逆に、emという単位は親要素のフォントサイズによって大きさが変化する。
このような単位を「相対単位」と呼ぶ。

・px
　→px（ピクセル）は相対単位。一見絶対単位のようですが、解像度によって大きさは変化します。
　　pxは親要素の影響を受けない。
　※ただし、スマホやタブレットで文字サイズを変更したい時は、一つ一つ変更しなくてはいけないので面倒になる場合も。また、pxを使用するとブラウザの文字サイズ変更機能が使えなくなるなどのデメリットもあり。

・%
　→・文字に使う場合は、emと同じような使い方となる。（親要素のフォントサイズによって大きさが変化する）
　　
　　・marginとpaddingで％（パーセント）を使う時は、【親要素の幅が基準】になる。親要素の高さ（height）は関係ない。
　　　例えば、width: 500px、height: 400pxの場合、margini-left: 10%とすると50pxとなり、magin-top: 10% とすると50pxとなる。（margin-topは40pxにはならない）
　　　これはpaddingも同様です。

　　・left,right,top,bottomでの％を使うときは、【left,rightのパーセントは親要素の幅が基準】となり、【top,bottomのパーセントは親要素の高さが基準】となる。

・em
　→emは親要素のフォントサイズによって大きさが変化する。
　　例えば、親要素を　font-size: 1.2em とした場合は、ブラウザのデフォルト値16pxを1.2倍した値（16px × 1.2 => 19.2px）になる。
　　上記の親要素に対し、その子要素にfont-size: 1.2em とした場合は、19.2px × 1.2 => 23.04px となる。
　　
　　emは文字のサイズだけではなく、「〇〇文字分の横幅」を要素に指定したい時にも使用できる。
　　4emなら、ちょうど4文字分収まる横幅ということになる。
　　この例では、pxを一切使用していないので、ブラウザで文字サイズの変更をするとそれが反映される。
　　※emの弱点は、HTMLの構造が複雑になると、どの要素の文字サイズが、どの子要素の文字サイズに影響を与えるか分かりにくくなるという点。
　　　→それを解決できるのが、remという単位。

・rem
　→remは親要素のフォントサイズに関係なく、htmlのフォントサイズ、もしくはブラウザのデフォルト値（16px）を基準に計算される。（親要素のフォントサイズの影響を受けない）
　　htmlにpxを指定しなければ、ブラウザの設定で文字サイズを変更することができる。

（・calc 計算ができる）
　→一方はwidth: 〇〇px として固定の幅にしておいて、もう一方はwidth: calc(100% - XXXpx)などとして可変の幅にする時にcalcは便利らしい。
　※IEで不具合が出る事もある模様。


◆max-width(max-height)、min-width(min-height)、vw、vhの違い

・max-width(max-height)：要素がこれ以上大きくならない幅（高さ）を指定することができる。width: ××%;とmax-width: 〇〇px;を組み合わせて使ったりすると、〇〇pxよ大きくならないようになる。また、画面から要素（例えば画像）がはみ出さないようにmax-width: 100%;とすると画面幅からはみ出なくなる。
　※max-width使用時に縦横比が崩れてしまった場合は、CSSに height: auto; を追加すると、縦横比を保ったまま画像が縮小されるようになる。
・min-width(min-height)：要素がこれ以上小さくならない幅（高さ）を指定することができる。width: ××%;とmin-width: 〇〇px;を組み合わせて使ったりすると、〇〇pxよりは小さくならないようになる。
・vh(Viewport Height）：viewportの高さに基づく。1vhはviewportの高さの1%に相当する
・vw(Viewport Width）：viewportの幅に基づく。1vwはviewportの幅の1%に相当する
（・vmin	（viewport minimum）：ビューポートの幅と高さのうち、値が小さい方に対する割合）
（・vmax	（viewport max）：ビューポートの幅と高さのうち、値が大きい方に対する割合）

◇viewportとは◇
　viewport（ビューポート）とは、日本語に訳すと「表示領域」という言葉がしっくりくる模様。
例えば、デスクトップ環境（PCなど）のブラウザなどでは、ブラウザウインドウの表示領域がviewportになる。ページがviewportからはみ出た場合は、スクロールをしてviewportを変えることができる。（普段から何気なくやってる操作）
スマートフォンでの表示のされ方は、制作者がmeta要素のviewportで指定することができる。
320px以上*のリキッドでページを作るのが、スマーフォンサイトには向いているらしい。
（日本国内に出回っている端末がほぼそれくらいの幅の模様。）

　meta要素のviewportの指定方法は、他のmeta要素と同じ。head要素内に、meta要素のname属性をviewportとして記述し、content属性に、viewportのプロパティとその値を記述して、meta viewportの指定する。
【例】
<meta name="viewport" content="width=360,initial-scale=1">
↑は、数字を明確に指定している（content="width=360 の部分）ので端末ごとの表示を統一できるが、逆に言うと大きな画面サイズの端末でも小さな画面サイズの端末と同じ表示になるため、スペースの有効活用ができないことが有る模様。

<meta name="viewport" content="width=device-width,initial-scale=1">
↑は端末ごとのサイズに応じてフレキシブルな表示ができる一方、細かい表示の統一はやりづらい模様。

◇Viewport単位（vh,vw,vmin,vmax）は、viewportの寸法を基準としているため、要素の幅、高さ、サイズをviewportに合わせて設定しなければならない状況で使える。
例えば、画像の幅を　% で指定した場合は対象となる要素のプロパティが「親要素の幅と紐付けられる」ため、必ずしもビューポートの幅が基準になるとは限らない。もし画像が div といったコンテナ要素の中にあれば、そのコンテナ要素の幅に対する割合で計算される。

★参考URL：https://app.codegrid.net/entry/whats-viewport
　　　　　https://dev.classmethod.jp/ria/html5/css-length-viewport/
　　　　　https://www.webprofessional.jp/css-viewport-units-quick-start/
　　　　　https://qiita.com/ryounagaoka/items/045b2808a5ed43f96607

◆色指定(カラーネーム、16進数、rgba、hsla)の違い

・カラーネーム
　→色の名前で指定する方法（color: red; など。）

・16進数
　→16進数は0~Fの16個の数字と文字で表される。9の次はAに進み、Fの次は10となって桁が上がる。
   #rrggbbまたは#rgb形式で指定する方法。（color: #000000; / #FFFFFFなど　←色はblack/whiteとなる）

・rgba
　→RGBカラーモデルのred・green・blueに、alphaが加わったもの。
　　alphaは「色の透明度」を表す。
　　※要素の透明度を指定するopacityプロパティは「セレクタ内全体が不透明になる」のに対し、RGBaは「プロパティのみ不透明」になる。「rgba」はプロパティの値を表すものということの違い。
　　　→例：background: rgba(0,0,255,0.5); blueの半透明 などなど。

・hsla
　→HSLとはhue(色相)、Saturation(彩度)、Lightness(明度)の事で、それに不透明度のAを足したのがhsla。
　　指定の仕方は、
　　色相のhueは、赤の0度からはじまって同じく赤の360度で終わるカラーサークル(色相環)の色の角度で指定する。
　　Saturation(彩度)とLightness(明度)は「%の単位で指定」する。
　　彩度が100%でもっとも鮮やかになり、0%ではその逆になる。
　　明度は100%で白になり、0%で黒になる。
　　50%が標準の明度の状態となる。
　　不透明度の値は0~1で、0は透明、1は不透明となる。

　　background: hsla(色相,彩度,明度,不透明度);
　　　→例：background: hsla(180,50%,50%,0.1); などなど。

◆相対パス、絶対パスの違い

　パス：pathとは英語で「道・通り道」という意味である。
　サイトのURLやファイルはリンクによって互いに結ばれているが、パスはその情報やファイルがどこにあるのかをたどってい雲の。
　HTMLでは、特定の情報にたどり着くまでのアプローチ方法が2種類あり、それぞれ「絶対パス」と「相対パス」と呼ばれる。

　・相対パス（relative path）
　　→今いる場所（階層）を基準にして、目的地（情報）がどこにあるのかを伝える。
　　　相対パスは自分がいる場所を起点にした位置。
　　　相対パスだと、ドメインが変わっても書き直さなくてもいい。
　　　それぞれのファイルがどの場所でどのように関連しているかを理解することが必要で、その関係性は同一サーバー内でのみ有効
　　
　　　相対パスを記述する際は以下の3つのようになる。
　　　・同じ階層内にあるファイル →ファイル名　で記述
　　　・同じ階層内にある、別フォルダの中にあるファイル → フォルダ名/ファイル名　で記述
　　　・今いる階層の1つ上の階層にあるファイル → ../ファイル名　で記述
　　　（※2つ上の階層にあるファイル の場合は「../../ファイル名」となります）


　・絶対パス（absolute path）
　　→URLでページを指定して、目的地（情報）がどこにあるのかを確実に伝える。
　　　絶対パスはトップからの位置。
　　　外部サイトへは、絶対パス以外は書けない。

★参考URL：https://techacademy.jp/magazine/5801